{"version":3,"sources":["../../src/db/directory.js"],"names":["_path","require","Directory","_isPt","currentdir","nodedir","replace","traverseDir","dir","npath","func","n","dpath","path","ch","children","child","Object","keys","childpath","resolve","console","log","isDirA","name","parts","sep","join","length","changeDir","_parts","change","dc","isdir","key","module","exports"],"mappings":"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","sourcesContent":["const _path = require(\"path\");\r\n\r\n/** module provides basic functionality for iterating and obtaining files from the directory.\r\n * it provides basic methods for the handling of higher level tasks like mutation of openfiles \r\n * or directories.\r\n */\r\nclass Directory {\r\n\r\n    /**  functionality which determines whether or not current directory.\r\n     * is an ancestor of directory being looked for by comparing the paths of   the respective directory.\r\n     * @param currentdir     String object containing the path of the current directory.\r\n     * @param nodedir      - string object contianing the path of the node being looked for.\r\n     * @returns              boolean value of whether or not it is an ancestor of the path.\r\n     */\r\n     _isPt(currentdir,nodedir) { return nodedir.replace(currentdir,'') != nodedir; }\r\n\r\n     /**traverse directory function.\r\n      * functionality recursively traverses directory returning the child node with the \r\n      * matching path given.\r\n      * @param dir       object containing the current section of the directory being traversed.\r\n      * @param npath     String object refering to the path of the child node we are looking for.\r\n      * @param func      function object which mutates node object as specified by the user. \r\n      *                  defaults to simply returning the node object.\r\n      * @returns Child node object of the child node being looked for or an empty object\r\n      * if child node is not found.\r\n      */\r\n    traverseDir(dir,npath,func=n => n) \r\n    {\r\n        let dpath = dir.path;\r\n        if (!this._isPt(dpath,npath) ) { return {}; }\r\n        if ( npath == dpath ) return func(dir);\r\n        let ch = dir.children;\r\n        for (let child of Object.keys(ch)) {\r\n            const childpath = _path.resolve(ch[child].path,child);\r\n            console.log(\" directory part \",dir,\"  parent \",this._isPt(childpath,npath));\r\n            if (npath == childpath) { \r\n                console.log(\" child object \",ch[child]);\r\n                console.log(\"file found \",npath); return func(ch[child]) ;\r\n                \r\n            }\r\n            if (this._isPt(childpath,npath) ) { \r\n                return this.traverseDir(ch[child],npath,func);\r\n            }\r\n        }\r\n    }\r\n\r\n    isDirA({path,name,parts}) {\r\n        return `${path}${_path.sep}${name}` == parts.join(_path.sep) && name == parts[parts.length-1];\r\n    }\r\n\r\n    /** functionality which mutates only a specific part of the \r\n     * current directory and return the current directory with the specific part having been updated.\r\n     * @param dir          Object contianing the current part of the directory being  iterated through.\r\n     * @param _parts       array containing each component of the path of the node we are searching for.\r\n     * @param change       functionality which mutates the specific directory node.\r\n     * @returns updated directory object with the updated node .\r\n     */\r\n    changeDir(dir,_parts,change) \r\n    {\r\n        //list of current children.\r\n        let dc = {};\r\n        if (!dir.isdir) return dir;\r\n        else {\r\n            dc = dir.children;\r\n            if (this.isDirA({ path:dir.path,name:dir.name,parts:_parts })) {\r\n                return change(dir);\r\n            }\r\n            //console.log(\" directory found \",dir);\r\n            for (let key of Object.keys(dc)) { \r\n                //if the current element is the final node in the dir tree.\r\n                // the node we are looking for.\r\n                console.log(\" file \",this.isDirA({ path:dc[key].path,name:key,parts:_parts }),key);\r\n                if ( this.isDirA({ path:dc[key].path,name:key,parts:_parts }) ) {\r\n                    console.log(\" directory found \",dc);\r\n                    dc[key] = change(dc[key]);\r\n                }   \r\n                else if ( this._isPt(dc[key].path,_parts.join(_path.sep)) ) {\r\n                    dc[key] = this.changeDir(dc[key],_parts,change);\r\n                }\r\n            }\r\n            //return the directory.\r\n        \r\n            return { ...dir,children:dc };\r\n        }\r\n        \r\n        \r\n    }\r\n}\r\n\r\nmodule.exports = Directory;"],"file":"directory.js"}